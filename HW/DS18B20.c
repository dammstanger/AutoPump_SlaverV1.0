
/******************** (C) COPYRIGHT 2016 DammStanger *****************************************
**--------------文件信息----------------------------------------------------------
 * 文件名	：DS18B20.c
 * 描	述	：DS18B20驱动	应用于STC12C5A60S2	11.0592MHz
 *            
 * 实验平台	：自控水泵V1.0  60S2 11.0592MHz
 * 硬件连接	：
 * 版 	本	：V0.1.160214
 * 从属关系	：PoolAuto
 * 库版本	：无
 * 创建时间	：2016.1.28
 * 最后编辑	：2016.2.14
 **-------------------------------------------------------------------------------

 * 作	者	：Damm Stanger
 * 邮	箱	：dammstanger@qq.com
**********************************************************************************************/

/****************************包含头文件*******************************************/
#include "DS18B20.h"
#include <stdio.h>
#include <intrins.h>
#include "globaldefine.h"

/****************************宏定义***********************************************/

/****************************变量声明*********************************************/

/****************************变量定义*********************************************/
sbit DQ_w = P4^3;   							//定义通信端口 

#if MULTI_SENSOR
uchar RomID[2][8]={0x28,0x25,0x8f,0x06,0x04,0x00,0x00,0x70,		//NO1:气压计温度
				   0x28,0xff,0x53,0xc6,0x01,0x15,0x03,0xf9};	//NO2:水池水度
#else
uchar RomID[1][8]={0};
#endif

uchar _00wbit[8]={2,2,2,2,2,2,2,2}; //初始化00写位组全部为填充位2


/********************************************************************************
 * 函数名：delay1us()
 * 描述  ：1us延时， //11.0592 STC1T 包括调用耗时 误差 -0.095775462963us
 * 输入  ：
 * 返回  ：-
 * 调用  ：内部
 ********************************************************************************/
void delay1us(void)  
{
}

/********************************************************************************
 * 函数名：DS18B20_delay1us()
 * 描述  ：18B20 的 1us延时， //11.0592 STC1T 包括调用耗时 实测大约3-5us
 * 输入  ：
 * 返回  ：-
 * 调用  ：内部
 ********************************************************************************/
void DS18B20_delay1us(uint i)	
{
	while(i--)
	delay1us();		
}

/********************************************************************************
 * 函数名：DS18B20_delay5us()
 * 描述  ：18B20 的 5us延时，//11.0592 STC1T i=100时t=0.53ms 步进5.3us
 * 输入  ：
 * 返回  ：-
 * 调用  ：内部
 ********************************************************************************/
void DS18B20_delay5us(uint i)	
{							
	while(i--)
	{
		delay1us();
		delay1us();
		delay1us();
		delay1us();
	}
}

/********************************************************************************
 * 函数名：delaynms()
 * 描述  ：毫秒延时，///11.0592MHz 1T 1一个单位1.0007ms
 * 输入  ：
 * 返回  ：-
 * 调用  ：内部
 ********************************************************************************/
void delaynms(uint n)   
{
    unsigned char a,b;
	for(;n>0;n--)			
		for(b=129;b>0;b--)
			for(a=20;a>0;a--);
}



/********************************************************************************
 * 函数名：DS18B20_Init()
 * 描述  ：初始化函数
 * 输入  ：
 * 返回  ：-
 * 调用  ：-
 ********************************************************************************/
void DS18B20_Init() 
{
	 uchar x=0;
	 DQ_w = 1;          //DQ复位
	 DS18B20_delay5us(1); 	//稍做延时
	 DQ_w = 0;          //单片机将DQ拉低
	 DS18B20_delay5us(100);	//精确延时 大于 480us
	 DQ_w = 1;          //拉高总线
	 DS18B20_delay5us(12);	
	 x=DQ_w;            //稍做延时后 如果x=0则初始化成功 x=1则初始化失败
	 DS18B20_delay5us(88);	//存在脉冲检测时间>480us
}

/********************************************************************************
 * 函数名：ReadOneBit()
 * 描述  ：读取一位
 * 输入  ：
 * 返回  ：-
 * 调用  ：内部
 ********************************************************************************/
uchar ReadOneBit()
{	
	uchar dat; 
	DQ_w = 0; 
	DQ_w = 1; 
	DS18B20_delay5us(1);
	dat=DQ_w;
	DS18B20_delay5us(4);
	return dat;
}

/********************************************************************************
 * 函数名：WriteOneBit()
 * 描述  ：写一位
 * 输入  ：
 * 返回  ：-
 * 调用  ：-
 ********************************************************************************/
void WriteOneBit(uchar dat)
{
	DQ_w = 0;
	DQ_w = dat;
	DS18B20_delay5us(5);  
	DQ_w = 1;
}


//
/********************************************************************************
 * 函数名：ReadOneChar()
 * 描述  ：读一个字节  
 * 输入  ：
 * 返回  ：-
 * 调用  ：-
 ********************************************************************************/
uchar ReadOneChar()
{	uchar dat;
	uchar i; 
	for (i=8;i>0;i--)
	{
		DQ_w = 0; 					// 给脉冲信号
		DS18B20_delay1us(1);		//>1us		
		dat>>=1;
		DQ_w = 1; 					// 
		DS18B20_delay5us(1);		//数据保持<15us
		if(DQ_w)
		dat|=0x80;
		DS18B20_delay5us(10);
	}
 	return(dat);
}


/********************************************************************************
 * 函数名：WriteOneChar()
 * 描述  ：写一个字节  
 * 输入  ：
 * 返回  ：-
 * 调用  ：-
 ********************************************************************************/
void WriteOneChar(uchar dat)
{
 uchar i;
 for (i=8; i>0; i--)
 {
//  uchar dat = 0;
  DQ_w = 0;
  DS18B20_delay1us(1);			//拉低到写数>1us
  DQ_w = dat&0x01;
  DS18B20_delay5us(10);  		//60us<T<120us
  DQ_w = 1;
  DS18B20_delay1us(1);
  dat>>=1;
 }
}



/********************************************************************************
 * 函数名：DS18B20_ReadTemperature()
 * 描述  ：读取温度
 * 输入  ：NO，传感器序号
 * 返回  ：-
 * 调用  ：外部
 ********************************************************************************/
uint DS18B20_ReadTemperature(uchar NO)			
{
	uchar  a=0, b=0;
	uint  t=0;
	uchar n;

	DS18B20_Init();
	WriteOneChar(0xCC); // 跳过读序号列号的操作
	WriteOneChar(0x44); // 启动温度转换
	delaynms(200);
	
	DS18B20_Init();
	#if MULTI_SENSOR
	WriteOneChar(0x55); //匹配ROM命令
	
	for(n=0;n<8;n++)
	  WriteOneChar(RomID[NO-1][n]); //读取64 bit ID
	#else
	WriteOneChar(0xCC); //跳过读序号列号的操作	
	#endif
	WriteOneChar(0xBE); //读取温度寄存器等（共可读9个寄存器） 前两个就是温度
	a=ReadOneChar();
	b=ReadOneChar(); 	//高位
//		
	//传感器返回值除16得实际温度值
	//为了得到2位小数位，先乘100，再除16，考虑整型数据长度，
	//技巧处理后先乘25，再除4，除4用右移实现

/**********此部分为判断温度的正负************/
//	sign=b;
//	if((bit)(sign>>4))
//	  flag=0;
//	else 
//	  flag=1;
/********************************************/
	  t = (b*256+a)*25;	
		return( t >> 2  );
}



/********************************************************************************
 * 函数名：DS18B20_Read_RomID()
 * 描述  ：读取设备ID
 * 输入  ：
 * 返回  ：-
 * 调用  ：外部
 ********************************************************************************/
void DS18B20_Read_RomID(char *id) 
{ 
	unsigned char i; 
	DS18B20_Init(); 

	WriteOneChar(0x33);  		// 读序列码的操作 
	for (i=0;i<8;i++)
		id[i] = ReadOneChar() ;  
}


/********************************************************************************
 * 函数名：_00wbitinit()
 * 描述  ：-
 * 输入  ：
 * 返回  ：-
 * 调用  ：-
 ********************************************************************************/
void _00wbitinit()
{
   uchar i;
   for (i=0;i<8;i++)
   {
   		_00wbit[i]=2;
   }
}

/********************************************************************************
 * 函数名：DS18B20_SearchRomID()
 * 描述  ：搜索总线上设备及ID
 * 输入  ：
 * 返回  ：-
 * 调用  ：外部
 ********************************************************************************/
#if MULTI_SENSOR
//搜索ID ROM
char DS18B20_SearchRomID()
{
	uchar Rom[64]={0}; 
	uchar i,j,R1,R2,d,finishflag=0;
	char  c=0; 
	for(i=0;i<2;i++) 							//暂时搜索两个器件的ID
	{ 
		DS18B20_Init(); 						//复位所有从机 
		WriteOneChar(0xf0); 					//主机发布搜索命令 
		for(j=0;j<64;j++) 
		{ 
			R1=ReadOneBit(); 					//读一位
			_nop_(); 
			R2=ReadOneBit(); 					//读该位补码 
			_nop_(); 
			if(R1==0&&R2==1)  					//未出现数据冲突，主机写0 
			{	
				Rom[j]=0; 
				WriteOneBit(0);
			}
			else if(R1==1&&R2==0)  				//未出现数据冲突，主机写1 
			{
				Rom[j]=1;
				WriteOneBit(1);
			} 
			else 
			{ 	LED1=0;
				if(_00wbit[c]==2) 				//出现新00写位 
				{ 
					WriteOneBit(0); 
					Rom[j]=0; 
					_00wbit[c]=0; 				//新00写位赋值为0 
					c++; 
				} 
				else if(_00wbit[c]==1)			//00写位组中00写位为1，主机写1 
			  	{												 
					WriteOneBit(1); 
					Rom[j]=1; 
					c++; 
				}
				else if(_00wbit[c]==0) 			//00写位组中00写位为0，主机写0 
				{ 
					WriteOneBit(0); 
					Rom[j]=0; 
					c++; 
				} 
			}
		}//end of for(j=0;j<64;j++) 
		//----------------------------------------------------------------------			
		for(j=0;j<64;j+=8)  					//将64位ROM编码整理成8字节存入RomID[n][8]中 
		{ 
			for(d=0;d<8;d++) 
			{ 
				if(Rom[j+d]&0x01)
				{ 
					RomID[i][j/8]>>=1; RomID[i][j/8]|=0x80; 
				} 
				else RomID[i][j/8]>>=1; 
			} 
		} 
		//-----------------------------------------------------------
		for(;c>=0;c--)  						//更新00写位数组 
		{
			if(_00wbit[c]==2)
			{
				continue;
			}
			if(_00wbit[c]==0)
			{
				_00wbit[c] = 1;
				break;
			}
			if(_00wbit[c]==1)
			{
				if(c>0)
				{
					_00wbit[c] = 2;
					continue;
				}
				else
				{
					finishflag = 1;
					break;
				}
			}	
		}	//end of while(c)
		c = 0;
		if(finishflag==1) {break;} 				//搜索结束标志位为1跳出 		
	}//end of for(i=0;i<16;i++)	
	_00wbitinit();
	DS18B20_Init(); 							//复位所有从机 
//	WriteOneChar(0xf0); 						//主机发布搜索命令 

	return(i+1);//返回总线上器件个数 
}

#endif

void SendTemp(uint temp)
{		
		SendByteNum(temp/10000);			// 百位显示值
		SendByteNum(temp/1000%10);			// 十位显示值
		SendByteNum(temp/100%10);			// 个位显示值
		SendOneByte('.');
		SendByteNum(temp/10%10);			//十分位显示值
		SendByteNum(temp%10);				//百分位显示值
}

void SendROMID(unsigned char n)
{	
	unsigned char i,j; 
	for(i=0;i<n;i++)
	{
		SendString("NO.");
		SendByteASCII(i+1);
		SendString(":\r\n");
		for(j=0;j<8;j++)
		{
			SendByteASCII(RomID[i][j]);
			SendOneByte(' ');
		}
		SendString("\r\n");
	}	
}

